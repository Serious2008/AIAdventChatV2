# RAG Comparison - Руководство

## Что это?

**RAG (Retrieval-Augmented Generation)** - это техника, которая улучшает ответы LLM, добавляя релевантный контекст из внешних источников (в нашем случае - из кодовой базы).

## Архитектура

```
Вопрос пользователя
        ↓
    ┌───┴────┐
    │        │
    ▼        ▼
БЕЗ RAG   С RAG
    │        │
    │        ├─→ 1. Векторный поиск (найти top-K релевантных чанков)
    │        │
    │        ├─→ 2. Построить контекст из найденных чанков
    │        │
    │        ├─→ 3. Объединить: Контекст + Вопрос → Промпт
    │        │
    ↓        ↓
  LLM      LLM
    │        │
    ↓        ↓
  Ответ    Ответ
    │        │
    └────┬───┘
         ↓
    Сравнение
```

## Как использовать

### 1. Подготовка

#### a) Настройте API ключи:
- **Settings** → **Claude API Key** - для LLM запросов
- **Settings** → **OpenAI API Key** - для векторных эмбеддингов

#### b) Проиндексируйте код:
1. Перейдите во вкладку **Search**
2. Введите путь к проекту или нажмите кнопку папки для дефолтного пути
3. Выберите типы файлов (Swift, Markdown, Text)
4. Нажмите **Index Directory**
5. Дождитесь окончания индексации

Пример:
```
Path: /Users/username/Documents/MyProject
Files: ✓ Swift ✓ Markdown
Result: 45 documents, 287 chunks indexed
```

### 2. Тестирование RAG

Перейдите во вкладку **RAG Compare**.

#### Примеры хороших вопросов:

**Вопросы о реализации:**
- "Как реализована аутентификация в проекте?"
- "Какие сервисы используются для работы с базой данных?"
- "Как работает векторный поиск?"

**Вопросы о конкретном функционале:**
- "Где обрабатываются ошибки API?"
- "Как происходит сохранение настроек?"
- "Какие MCP серверы поддерживаются?"

**Вопросы об архитектуре:**
- "Какие основные компоненты есть в ChatViewModel?"
- "Как организована работа с SQLite?"
- "Какие паттерны используются для UI?"

### 3. Анализ результатов

После нажатия **Сравнить ответы** вы увидите:

#### a) Статистика:
- **Время с RAG**: Включает поиск + генерацию
- **Время без RAG**: Только генерация
- **Использовано источников**: Количество найденных чанков

#### b) Использованные источники:
```
1. ChatViewModel.swift - 85.3%
   "class ChatViewModel: ObservableObject { @Published var..."

2. ClaudeService.swift - 78.9%
   "func sendMessage(messages: [Message]) async throws..."
```

#### c) Side-by-side сравнение:
- **Слева (зелёный)**: Ответ С RAG - содержит конкретные детали из кода
- **Справа (оранжевый)**: Ответ БЕЗ RAG - общие знания модели

#### d) Анализ:
- **RAG помог**: Где контекст улучшил ответ
- **Ограничения RAG**: Где контекст был недостаточен

## Когда RAG помогает

### ✅ RAG эффективен для:

1. **Вопросы о конкретной реализации**
   ```
   Вопрос: "Как сохраняются настройки?"

   С RAG: "Настройки сохраняются через UserDefaults в классе Settings.
          Каждое поле имеет didSet observer, который автоматически
          сохраняет значение. Например:
          @Published var apiKey: String {
              didSet { UserDefaults.standard.set(apiKey, forKey: \"ClaudeAPIKey\") }
          }"

   Без RAG: "Обычно настройки сохраняются через UserDefaults или
            другие механизмы персистентности."
   ```

2. **Вопросы о специфичных для проекта решениях**
   - Используемые библиотеки
   - Кастомные протоколы
   - Внутренние API

3. **Вопросы требующие точных деталей**
   - Названия функций/классов
   - Сигнатуры методов
   - Структура данных

### ❌ RAG менее эффективен для:

1. **Общие вопросы о программировании**
   - "Что такое async/await в Swift?"
   - "Как работает MVVM паттерн?"

2. **Концептуальные вопросы**
   - "Какие best practices для iOS разработки?"
   - "Когда использовать struct vs class?"

3. **Вопросы требующие рассуждений**
   - "Как улучшить производительность?"
   - "Какую архитектуру выбрать?"

## Метрики качества

### Релевантность источников:

- **> 70%** - Высокая релевантность (зелёный)
  - Источник прямо отвечает на вопрос
  - Содержит искомые детали

- **50-70%** - Средняя релевантность (оранжевый)
  - Частично релевантный контекст
  - Может помочь, но не полностью

- **< 50%** - Низкая релевантность (красный)
  - Слабая связь с вопросом
  - Возможно нужно переформулировать

### Оценка улучшения:

Сравните ответы по критериям:

1. **Конкретность** - Есть ли конкретные имена/значения?
2. **Точность** - Соответствует ли реальному коду?
3. **Полнота** - Покрывает ли все аспекты вопроса?
4. **Ссылки** - Указаны ли файлы/функции источники?

## Примеры тестирования

### Тест 1: Специфичный вопрос о реализации

```
Вопрос: "Как в проекте реализован векторный поиск?"

Ожидание:
- С RAG: Детальное описание VectorSearchService, EmbeddingService,
         VectorStorage с упоминанием OpenAI API и SQLite
- Без RAG: Общее описание векторного поиска без конкретики

Результат: ✅ RAG значительно лучше
```

### Тест 2: Вопрос о внешних библиотеках

```
Вопрос: "Какие внешние библиотеки используются?"

Ожидание:
- С RAG: Конкретный список из Package.swift или импортов
- Без RAG: Предположения о типичных библиотеках

Результат: ✅ RAG предоставляет точный список
```

### Тест 3: Общий вопрос

```
Вопрос: "Что такое MVVM паттерн?"

Ожидание:
- С RAG: Может найти примеры из кода, но объяснение будет
         основано на общих знаниях
- Без RAG: Стандартное объяснение паттерна

Результат: ≈ Примерно одинаково, RAG не даёт преимущества
```

## Troubleshooting

### Проблема: Низкая релевантность всех источников

**Решение:**
1. Проверьте что код проиндексирован (Search → Statistics)
2. Попробуйте более конкретный вопрос
3. Убедитесь что ищете информацию из проиндексированных файлов

### Проблема: "No relevant context found"

**Причины:**
- Индекс пустой - нужно проиндексировать код
- Вопрос слишком общий
- Информация не содержится в проиндексированных файлах

**Решение:**
1. Проверьте индекс: Search → Statistics
2. Попробуйте другую формулировку вопроса
3. Добавьте больше файлов в индекс

### Проблема: Ответы идентичны

**Причины:**
- Модель игнорирует контекст
- Контекст не релевантен
- Вопрос слишком общий

**Решение:**
- Задайте более специфичный вопрос про код
- Проверьте релевантность найденных источников

## Создание демо-видео

### Сценарий видео:

1. **Вступление (30 сек)**
   - Показать главный экран
   - Объяснить что такое RAG

2. **Подготовка (1 мин)**
   - Settings: показать API ключи (замазать реальные)
   - Search: проиндексировать проект
   - Показать статистику: X документов, Y чанков

3. **Демонстрация (3 мин)**

   **Пример 1: Хороший кейс для RAG**
   ```
   Вопрос: "Как реализована работа с SQLite в ChatViewModel?"

   Результат:
   - С RAG: Конкретные методы, упоминание DatabaseManager
   - Без RAG: Общее описание работы с SQLite
   - Релевантность: 85%, 3 источника
   ```

   **Пример 2: Средний кейс**
   ```
   Вопрос: "Какие есть настройки в приложении?"

   Результат:
   - С RAG: Список из Settings.swift
   - Без RAG: Предположения о типичных настройках
   - Релевантность: 72%, 2 источника
   ```

   **Пример 3: Слабый кейс для RAG**
   ```
   Вопрос: "Что такое SwiftUI?"

   Результат:
   - С RAG: Находит примеры SwiftUI кода, но объяснение общее
   - Без RAG: Стандартное объяснение
   - Релевантность: 45%, контекст не помогает
   ```

4. **Анализ (1 мин)**
   - Показать секцию "Анализ" в UI
   - Объяснить когда RAG помог, когда нет
   - Показать метрики релевантности

5. **Заключение (30 сек)**
   - Выводы: RAG эффективен для специфичных вопросов о коде
   - Не эффективен для общих концептуальных вопросов

### Технические требования к видео:

- Разрешение: 1920x1080 или выше
- Формат: MP4, H.264
- Длительность: 5-6 минут
- Звук: Чистый голос, без шумов
- Субтитры: Желательно

### Инструменты для записи:

**macOS:**
- QuickTime Player (бесплатно)
- OBS Studio (бесплатно, больше возможностей)
- ScreenFlow (платно, профессионально)

**Команда для записи экрана:**
```bash
screencapture -v output.mov
```

## Код для демонстрации

### Пример использования в коде:

```swift
// Создать RAG comparison
let result = try await chatViewModel.compareRAG(
    question: "Как работает векторный поиск?",
    topK: 5
)

print("С RAG: \(result.withRAG)")
print("Без RAG: \(result.withoutRAG)")
print("Источников: \(result.usedChunks.count)")

// Использовать только RAG
let ragResponse = try await chatViewModel.answerWithRAG(
    question: "Где обрабатываются ошибки?"
)

print("Ответ: \(ragResponse.answer)")
print("Время: \(ragResponse.processingTime)s")
print("Источники:")
for chunk in ragResponse.usedChunks {
    print("  - \(chunk.chunk.fileName): \(chunk.similarity * 100)%")
}
```

## Заключение

RAG - мощная техника для улучшения ответов LLM на вопросы о конкретной кодовой базе. Используйте RAG Comparison View для:

✅ Тестирования эффективности RAG на ваших данных
✅ Оптимизации промптов и параметров поиска
✅ Демонстрации преимуществ RAG
✅ Анализа качества индексации

Успешного тестирования! 🚀
